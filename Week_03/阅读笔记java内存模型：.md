volatile：**轻量级的synchronized，在多核处理器开发中保证了共享变量的“可见性”，可见性是指一个线程修改一个变量时，另外一个线程能够读到这个修改的值**。volatile变量修饰符不会引起线程上下文的切换和调度。它比synchronized的使用和执行成本更低。

缓存行：cpu高速缓存中可以分配的最小存储单位，处理器填写缓存行时会加载整个缓存行，现代cpu需要执行几百次cpu指令

**在多核处理器下：**

有volatile变量修饰的共享变量进行写操作的时候经过编译生成的汇编代码有一个lock指令

Lock前缀的指令在多核处理器下会引发两件事情：
1：将当前处理器缓存行的数据写回到系统内存

2：这个写回内存的操作会使在其他cpu里缓存了该内存地址的数据无效

进行这两件事情的步骤：如果volatile的变量进行写操作，jvm就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存（因为写操作会先改变内存），但是，其他处理器还会保有旧值，在进行计算操作就会有问题，所以多核处理器，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期（嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效），当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存读取数据到处理器缓存里。（相当于缓存锁机制）

这里提到总线锁:锁住内存：当一个处理器在总线上输出锁信号，其他处理器的请求将被锁住

锁的级别（从低到高）：所可以升级但是不能降级：无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态

# java内存模型：

并发编程需要解决的是：线程之间如何通信以及线程之间如何同步

通信是指线程之间以何种机制来交换信息。线程之间通信机制有两种:共享内存和消息传递。

共享内存：线程之间共享程序的公共状态，**通过写-读内存中的公共状态进行隐式通信**，在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显示进行通信。

同步是指程序中用于控制不同线程间操作发生相对顺序的机制，在共享内存并发模型中**同步是显示进行**的，程序猿必须显示指定某个方法或某段代码需要在线程之间互斥执行，在消息传递的并发模型里，由于消息的发送必须在小消息的接收之前，因此同步是隐式进行的。

java线程之间的通信由java内存模型（本文简称jmm来控制）

happens-before：如果一个操作需要对另一个操作可见，那么这两个操作之间就必须要存在happens-before关系，两个操作即可以是在一个线程内，也可以是在不同线程之间。

as-if-serial：不管怎么重排序，程序的执行结果不能被改变。

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果

顺序一致性模型：

一个线程中的所有操作必须按照程序的顺序来执行

（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

volatile写读内存的含义：
如果把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变的对读线程B可见（因为要将本地内存的共享变量的值刷新到主内存）

线程A写一个volatile变量，随后线程B读这个volatile，这个过程实质上是线程A通过主内存向线程B传递消息。

**volatile的写/读与锁的释放，获取具有相同的内存语义**

由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性，再功能上，锁比volatile更强大，在可伸缩性和执行性能上，volatile更有优势，只要volatile变量与普通变量之间的重排序可能会破幻volatile的内存语义（锁的释放获取），比如造成结果的不一致性，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。

as-if-serial：语义保证单线程内程序的执行结果不被改变，happens-before：关系保证正确同步的多线程程序的执行结果不被改变。